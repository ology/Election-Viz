#!/usr/bin/perl

=head1 PROGRAM

Convert the wikipedia C<wikitable> for presidential election results, by state,
into a columnar data file.

=head2 AUTHOR

Gene Boggs C<gene plus github at ology dot net>

=head2 TO DO

Investigate L<MediaWiki::DumpFile>

=cut

use strict;
use warnings;

use WWW::Wikipedia;

# Get the year from the commandline.
my $year = shift || 2012;

# Cached raw data file.
my $filename = sprintf 'data/raw-%d.txt', $year;

# String to hold the harvest or read results.
my $text = '';

# Cache or harvest?
if (-e $filename) {
    warn "Cached data exists in $filename\n";
    # Read the cashed wikipedia text.
    local $/;
    open my $input, '<', $filename or die "Can't read $filename: $!";
    # Set the text for matching.
    $text = <$input>;
}
else {
    # Construct the entry title.
    my $title = 'United_States_presidential_election,_' . $year;
    warn "Harvesting new data from entry: '$title'\n";
    # Harvest from wikipedia.
    my $wiki  = WWW::Wikipedia->new;
    my $entry = $wiki->search($title) or die "ERROR: No such entry\n";
    # Cache the raw entry.
    open my $output, '>', $filename or die "Can't write to $filename: $!";
    print $output $entry->fulltext;
    # Set the text for matching.
    $text = $entry->fulltext;
}

# Isolate the election results table.
if ( $text =~ /
    \A
    .*?
    (?:Results|Votes)\s+by\s+state  # Election results table marker
    \s*
    (.+?)                           # Election results table data
    (?:U\.S\.?\s*Total|TOTALS:?)    # End of data table
    .+?
    \Z
    /msix
) {
    $text = $1;
    # Match all years except 2000.
    if ( $text =~ /
        \A
        .+?
        \{ \s* \|   # wikitable start
        .+?
        \| \s* \}   # wikitable end
        (.+?)       # Actual, useful data
        \Z
        /msx
    ) {
#        die "1 Matched!\n";
        $text = $1;
#        die "1 Matched:\n$text\n";
    }
    else {
        # Match year 2000.
        if ( $text =~ /
            \A
            .+?
            \{ \s* \|   # wikitable start
            (.+?)       # Actual, useful data
            \Z
            /msx
        ) {
#            die "2 Matched!\n";
            $text = $1;
#            die "2 Matched:\n$text\n";
        }
        else {
            die "2 Can't match table\n";
        }
    }
}
else {
    die "1 Can't match text\n";
}

# Ameliorate wikipedia franken-markup.
$text =~ s/\{*//msg;
$text =~ s/[\w-]+[=:]"?[\w :-]+[%;]?"?//g; # Remove attribute settings.
$text =~ s/[[:^ascii:]]//g; # Purge any non-ascii chars.
$text =~ s/&nbsp;//g; # Remove literal spaces.
$text =~ s/^!\s*//msg; # Remove wikinewline artifact.
$text =~ s/<br>/ /g; # Handle html linebreaks.
$text =~ s/<.+?>//msg; # Remove all <elements>.
$text =~ s/<(\w+).+?><\/\1>//msg; # Remove all <elements>.
$text =~ s/-\n\|//g; # Eliminate wikinewlines.
$text =~ s/!+/!/g; # Replace double !s with singles.
$text =~ s/\s*\|\s*\|\s*/\|/msg; # Replace double |s with singles.
$text =~ s/\n\|ColumbiaDistrict of//; # Remove 2012 edge case artifact.
# Handle entries before y2k.
if ( $year < 2000 ) {
    # Remove stray attribute artifacts.
    $text =~ s/="?\w+"?//g;
    $text =~ s/\d+%"//g;
    $text =~ s/data-sort-?//g;
    $text =~ s/font-size://g;
}

# Declare the table parts.
my ($candidates, $headers, $data);

# Extract the table parts.
if ( $year < 2000 && $text =~ /\A(.+?)Margin.+?(State.+?)(Alabama.+?)\Z/ms ) {
    # Process parts for 1900 - 1996.
    ($candidates, $headers, $data) = ($1, $2, $3);
    $headers =~ s/\s*\|\s*\Z//g; # Trim trailing |s.
}
elsif ( $year >= 2000 && $year < 2012 && $text =~ /\A(.+?)(Alabama.+?)\Z/ms )  {
    # Process parts for 2000 - 2008.
    ($headers, $data) = ($1, $2);
    # Handle franken-markup. Order matters.
    $headers =~ s/\|-\s*//g; # Remove superflous bits.
    $headers =~ s/!/\|/g; # !s become |s.
    $headers =~ s/-\n//g; # Un-hyphenate cells.
    $headers =~ s/\A\s*\|\s*//g; # Trim leading |s.
    $headers =~ s/\n/\|/g; # Add trailing |s.
    $headers =~ s/\|\|/\|/g; # Double ||s become single.
    $headers =~ s/\s*\|\s*\Z//g; # Trim trailing |s.

    # Extract the candidates from the headers!
    $candidates = $headers;
    $candidates =~ s/State|Electors|Margin|Total//g; # Remove non-candidate entries.
    $candidates =~ s/\s*%\s*//g; # Remove non-candidate entries.
    $candidates =~ s/\|\|/\|/g; # Double ||s become single.
    $candidates =~ s/\A\s*\|\s*\|?\s*//; # Trim leading |s.
    $candidates =~ s/\s*\|?\s*\|\s*\Z//; # Trim trailing |s.
}
elsif ( $year >= 2012 && $text =~ /\A(.+?)Margin.+?(State.+?)(Alabama.+?)\Z/ms )  {
    # Process parts for 2012.
    ($candidates, $headers, $data) = ($1, $2, $3);
}
else {
    # Fall-through.
    die "Unsure how to proceed with the given input.\n";
}

print
"* Candidates:\n\n", $candidates,
"\n\n",
"* Headers:\n\n", $headers,
;
__END__

# Extract the candidates unless they are alread defined.
my @candidates = split /\s*\|\s*/ms, $candidates;

# Extract the header row.
my @headers = split /\s*\|\s*/, $headers;

# Replace spurious |s with spaces.
$data =~ s/\|/ /msg;

# Extract the data rows.
my @data = $data =~ /([A-Z]\w{3,}(?: \w+)?.+?[A-Z]{2} -?)/msg;

# Split the rows into cells of individual data.
@data = map { [ split(/ /, $_) ] } @data;

# Sanitize the data one last time.
for my $row (@data) {
    # Fix 2-name states.
    if ( $row->[0] =~ /^\w+$/ && $row->[1] =~ /^\w+$/ ) {
        my $name = shift @$row;
        $row->[0] = "$name $row->[0]";
    }

    # Eliminate empty entries.
    @$row = grep { $_ ne '' } @$row;
}

# Output the table.
print join("\|", @candidates), "\n";
print join("\|", @headers), "\n";
print join("\n", map { join "\|", @$_ } @data);

